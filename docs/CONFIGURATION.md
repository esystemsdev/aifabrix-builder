# Configuration Reference

→ [Back to Quick Start](QUICK-START.md)

Simple reference for all configuration files.

## variables.yaml

Generated by `aifabrix create`. Defines your application.

### Required Fields

**app.key**  
Unique identifier (lowercase, dashes only)  
Example: `myapp`, `my-api`, `data-processor`

**app.displayName**  
Human-readable name shown in UIs  
Example: `"My Application"`, `"Data Processor API"`

**app.description**  
What your app does  
Example: `"Processes customer data and generates reports"`

**app.type**  
Application type for Azure  
Options: `webapp`, `api`, `service`, `functionapp`

**port**  
Container internal port  
Example: `3000`, `8080`, `5000`

**image.name**  
Docker image name  
Example: `myapp`, `my-company/myapp`

**image.registry**  
Container registry URL  
Example: `myacr.azurecr.io`, `docker.io`

**image.registryMode**  
Registry type  
Options: `acr`, `external`, `public`

**build.language**  
Runtime language  
Options: `typescript`, `python`

### Optional Fields

**build.localPort**  
Port for local development (if different from container port)  
Example: `3001`

**build.containerPort**  
Container internal port (if different from main port)  
Example: `8080`  
*Defaults to `port` if not specified*

**build.dockerfile**  
Custom Dockerfile path  
Example: `Dockerfile`, `custom/Dockerfile.prod`  
*Leave empty to auto-generate*

**build.context**  
Docker build context  
Default: `.` (current directory)

**build.secrets**  
Path to secrets file  
Default: `~/.aifabrix/secrets.yaml`  
Example: `../../secrets.local.yaml`

**build.envOutputPath**  
Where to copy `.env` file  
Example: `../.env`, `../src/.env`

**requires.database**  
Set `true` if you need database  
Generates database config in env.template

**requires.databases**  
List of database names  
Example:
```yaml
databases:
  - name: myapp
  - name: myapp-analytics
```

**requires.redis**  
Set `true` if you need Redis  
Generates Redis config in env.template

**requires.storage**  
Set `true` if you need file storage  
Mounts `/mnt/data` in container

**deployment.controllerUrl**  
Controller API URL for pipeline deployments  
Example: `https://controller.aifabrix.ai`  
*Optional - enables automated deployment*

**deployment.environment**  
Target environment for deployment  
Example: `miso`, `dev`, `tst`, `pro`  
*Optional - uses root-level environment from config.yaml if not specified*

**Note:** Client credentials are no longer stored in variables.yaml. They are read from `~/.aifabrix/secrets.local.yaml` using pattern `<app-name>-client-idKeyVault` and `<app-name>-client-secretKeyVault`. Tokens are automatically retrieved or refreshed during deployment.

### Full Example

```yaml
app:
  key: myapp
  displayName: "My Application"
  description: "Does amazing things"
  type: webapp

image:
  name: myapp
  registry: myacr.azurecr.io
  registryMode: acr

port: 3000

requires:
  database: true
  databases:
    - name: myapp
    - name: myapp-logs
  redis: true
  storage: false

build:
  language: typescript
  localPort: 3001
  dockerfile: ""  # Auto-generate
  context: .
  secrets: "../../secrets.local.yaml"
  envOutputPath: ../.env

healthCheck:
  path: /health
  interval: 30

authentication:
  type: keycloak
  enableSSO: true
  requiredRoles: ["user"]
```

**Health Check Response Formats:**

The health check endpoint must return HTTP 200 status code and a JSON response with one of the following formats:

1. **Keycloak Format:**
   ```json
   {"status": "UP", "checks": []}
   ```
   Validation: `status === "UP"`

2. **Standard Format:**
   ```json
   {"status": "ok", "database": "connected"}
   ```
   Validation: `status === "ok" && (database === "connected" || !database)`

3. **Alternative Format:**
   ```json
   {"status": "healthy", "service": "dataplane"}
   ```
   Validation: `status === "healthy"`

4. **Success-based Format:**
   ```json
   {"success": true, "message": "Service is running"}
   ```
   Validation: `success === true`

5. **Non-JSON Format:**
   ```
   OK
   ```
   Validation: HTTP status code === 200 (any non-JSON response with 200 status is considered healthy)

**Note:** For non-JSON responses, only the HTTP status code is checked. A 200 status code indicates a healthy service.

---

## env.template

Environment variables template. SDK generates `.env` from this + secrets.

### Standard Variables (Auto-added)

If `requires.database: true`:
```bash
DATABASE_URL=kv://databases-0-urlKeyVault
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USER=pgadmin
DATABASE_PASSWORD=kv://postgres-passwordKeyVault
DATABASE_NAME=myapp
```

If `requires.redis: true`:
```bash
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=
```

### Your Variables

Add whatever your app needs:
```bash
NODE_ENV=development
PORT=3000
LOG_LEVEL=debug

# API Keys (use kv:// for secrets)
API_KEY=kv://my-api-keyKeyVault
OPENAI_API_KEY=kv://openai-keyKeyVault

# Feature Flags
ENABLE_ANALYTICS=true
ENABLE_CACHE=true

# External Services
PAYMENT_API_URL=https://api.payment.com
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
```

### kv:// References

`kv://name` means "get value from secrets file"

**Secrets file location:**
- Default: `~/.aifabrix/secrets.yaml`
- Override: Set `build.secrets` in variables.yaml

**Example secrets.yaml:**
```yaml
my-api-keyKeyVault: "sk-1234567890abcdef"
openai-keyKeyVault: "sk-proj-xyz..."
postgres-passwordKeyVault: "admin123"
```

**Encrypted secrets:**
Secrets can be encrypted using `aifabrix secure` command. Encrypted values use `secure://` prefix and are automatically decrypted when loaded. See [Secrets Encryption](#secrets-encryption) section below.

**Resolution:**
```bash
# Before (env.template)
API_KEY=kv://my-api-keyKeyVault

# After (.env generated)
API_KEY=sk-1234567890abcdef
```

**Note:** Encrypted secrets (with `secure://` prefix) are automatically decrypted during resolution. The encryption key is retrieved from `~/.aifabrix/config.yaml`.

### Existing .env Files

Have an existing `.env`? 

`aifabrix create` reads it and converts to template:
- Regular values stay as-is
- Sensitive values (passwords, keys) → `kv://` references

### Secrets Encryption

For ISO 27001 compliance, secrets can be encrypted at rest using the `aifabrix secure` command. Encrypted secrets use the `secure://` prefix format and are automatically decrypted when loaded.

**Encryption Format:**
Encrypted values use the format: `secure://<iv>:<ciphertext>:<authTag>`
- All components are base64 encoded
- Uses AES-256-GCM encryption algorithm
- IV (Initialization Vector): 96 bits, randomly generated per encryption
- Ciphertext: Encrypted secret value
- Auth Tag: 128-bit authentication tag for integrity verification

**Example:**
```yaml
# Before encryption (secrets.local.yaml)
# API Configuration
my-api-keyKeyVault: "sk-1234567890abcdef"
database-passwordKeyVault: "admin123"

# Service URLs (not encrypted)
api-url: "https://api.example.com"

# After encryption with aifabrix secure (comments preserved)
# API Configuration
my-api-keyKeyVault: "secure://xK9mP2qR5tW8vY1z:AbCdEfGhIjKlMnOpQrStUvWxYz1234567890abcdef:ZxYwVuTsRqPoNmLkJiHgFeDcBa9876543210"
database-passwordKeyVault: "secure://yL0nQ3rS6uX9wZ2a:BcDeFgHiJkLmNoPqRsTuVwXyZa2345678901bcdefg:YwXvUtSrQpOnMlKjIhGfEdCbA8765432109"

# Service URLs (not encrypted - URLs are not secrets)
api-url: "https://api.example.com"
```

**Note:** The `aifabrix secure` command preserves all comments, blank lines, and formatting. URLs (starting with `http://` or `https://`) are automatically skipped as they are not secrets.

**Encrypting Secrets:**
```bash
# Encrypt all secrets (interactive - prompts for encryption key)
aifabrix secure

# Encrypt with provided key (hex format, 64 characters)
aifabrix secure --secrets-encryption "a1b2c3d4e5f6789abcdef1234567890abcdef1234567890abcdef1234567890ab"

# Encrypt with base64 key (44 characters)
aifabrix secure --secrets-encryption "YWJjZGVmZ2hpams="
```

**Encryption Key:**
- **Format**: 32 bytes (256 bits)
  - Hex: 64 hexadecimal characters
  - Base64: 44 base64 characters
- **Storage**: Saved to `~/.aifabrix/config.yaml` as `secrets-encryption-key`
- **Usage**: Automatically retrieved for decryption when loading secrets
- **Security**: Store encryption key securely (e.g., password manager, secure vault)

**What Gets Encrypted:**
- User secrets: `~/.aifabrix/secrets.local.yaml`
- App build secrets: Files specified in `build.secrets` in each app's `variables.yaml`
- General secrets: File specified in `secrets-path` in `config.yaml` (if configured)

**Automatic Decryption:**
Encrypted secrets are automatically decrypted when:
- Running `aifabrix resolve` to generate `.env` files
- Building Docker images with `aifabrix build`
- Deploying applications with `aifabrix deploy`
- Any command that loads secrets

The encryption key is automatically retrieved from `~/.aifabrix/config.yaml`. No manual decryption is required.

**Security Best Practices:**
- **Encrypt before committing**: Encrypt secrets before committing to version control
- **Key management**: Store encryption key securely (password manager, secure vault)
- **Key rotation**: Re-run `aifabrix secure` with a new key to rotate encryption
- **File permissions**: Encrypted files are automatically set to 0o600 (owner read/write only)
- **Backup encryption key**: Ensure encryption key is backed up securely - losing it means losing access to encrypted secrets

**Backward Compatibility:**
Plaintext secrets continue to work if no encryption key is configured. The system automatically detects encrypted values (by `secure://` prefix) and only attempts decryption when needed.

**Troubleshooting:**
- **"Decryption failed"**: Encryption key in `config.yaml` doesn't match the key used for encryption
- **"Invalid encryption key format"**: Key must be 32 bytes (64 hex chars or 44 base64 chars)
- **"No secrets files found"**: Create `~/.aifabrix/secrets.local.yaml` or configure `build.secrets` in `variables.yaml`

For more details, see [aifabrix secure](CLI-REFERENCE.md#aifabrix-secure) command documentation.

---

## rbac.yaml

Roles and permissions. Only created if `authentication: true` during `aifabrix create`.

### Structure

```yaml
roles:
  - name: "User"              # Display name
    value: "user"             # Code identifier (lowercase, dashes)
    description: "Basic user access"
  
  - name: "Admin"
    value: "admin"
    description: "Administrator access"

permissions:
  - name: "app:read"          # Permission identifier
    roles: ["user", "admin"]  # Roles that have this permission
    description: "Read access to application"
  
  - name: "app:write"
    roles: ["admin"]          # Only admins can write
    description: "Write access to application"
```

### Role Naming

**name** - Human-readable, shown in UIs  
Example: `"Platform Administrator"`, `"Content Editor"`

**value** - Code identifier, used in JWT tokens  
Example: `platform-admin`, `content-editor`  
Pattern: lowercase, dashes only

### Permission Naming

Pattern: `resource:action` or `feature:action`

**Examples:**
- `documents:read`
- `documents:write`
- `users:manage`
- `reports:export`
- `settings:admin`

### Why rbac.yaml?

- **Contract with miso-controller** - Defines what roles/permissions your app has
- **Configuration-driven** - No need to hardcode roles in your application
- **Audit trail** - miso-controller tracks all access decisions
- **Centralized management** - Update roles without code changes

---

## config.yaml

Stored in `~/.aifabrix/config.yaml`. Manages authentication tokens and selected environment.

### Structure

```yaml
developer-id: 0
environment: miso  # Root-level: currently selected environment
device:  # Root-level: device tokens keyed by controller URL (universal per controller)
  http://localhost:3010:
    token: device-token-123
    refreshToken: refresh-token-456
    expiresAt: 2024-01-01T12:00:00.000Z
  https://dev-controller.example.com:
    token: dev-device-token
    refreshToken: dev-refresh-token
    expiresAt: 2024-01-01T12:00:00.000Z
environments:
  miso:
    clients:  # Client tokens per environment and app
      keycloak:
        controller: http://localhost:3010
        token: client-token-456
        expiresAt: 2024-01-01T12:00:00.000Z
  dev:
    clients:
      myapp:
        controller: https://dev-controller.example.com
        token: dev-client-token
        expiresAt: 2024-01-01T12:00:00.000Z
```

### Fields

**developer-id**  
Developer ID for local infrastructure isolation  
Default: `0` (shared infrastructure)  
Example: `1`, `2`, `5` (developer-specific ports)

**environment** (root-level)  
Currently selected environment  
Updated when `--environment` flag is provided in login or deploy commands  
Example: `miso`, `dev`, `tst`, `pro`

**device** (root-level)  
Device code flow tokens, keyed by controller URL (universal per controller, not per environment)  
- `device.\<controller-url\>.token` - Device access token  
- `device.\<controller-url\>.refreshToken` - Refresh token for automatic token renewal  
- `device.\<controller-url\>.expiresAt` - Token expiration timestamp (ISO 8601)

**environments**  
Per-environment client token storage

**environments.\<env\>.clients.\<app-name\>**  
Client credentials token for app in environment  
- `controller` - Controller URL  
- `token` - Client authentication token  
- `expiresAt` - Token expiration timestamp (ISO 8601)

### Important Notes

- **Never stores credentials** - Only tokens are stored in config.yaml
- **Automatic token refresh** - Tokens are automatically refreshed when expired (device tokens use refresh tokens, client tokens use credentials from secrets.local.yaml)
- **Environment selection** - Root-level `environment` indicates current environment
- **Device tokens** - Stored at root level, keyed by controller URL (universal per controller, not per environment)
- **Client tokens** - Stored per environment and app, automatically refreshed using credentials from secrets.local.yaml
- **Refresh tokens** - Device tokens include refresh tokens for automatic renewal on 401 errors

---

## secrets.local.yaml

Stored in `~/.aifabrix/secrets.local.yaml`. Contains client credentials for applications.

### Structure

Flat key-value pairs using pattern: `<app-name>-client-idKeyVault` and `<app-name>-client-secretKeyVault`

```yaml
keycloak-client-idKeyVault: miso-controller-miso-keycloak
keycloak-client-secretKeyVault: YY_j0RdTWBPEA4Seb1uTdR4RbGs1Sy48QhA3vkmz0_c
myapp-client-idKeyVault: myapp-client-id
myapp-client-secretKeyVault: myapp-client-secret
postgres-passwordKeyVault: admin123
redis-passwordKeyVault: redis-secret
```

### Pattern

For application client credentials:
- **Client ID key:** `<app-name>-client-idKeyVault`
- **Client Secret key:** `<app-name>-client-secretKeyVault`

**Example for app `keycloak`:**
- `keycloak-client-idKeyVault` → Client ID
- `keycloak-client-secretKeyVault` → Client Secret

### Usage

Credentials are read from secrets.local.yaml when:
- Running `aifabrix login --method credentials --app <app-name>`
- Running `aifabrix deploy <app>` (if token is missing or expired)

**Important:**
- This file structure is **read-only** - never modified by the CLI
- Credentials are **never** stored in config.yaml - only tokens
- File permissions: `600` (read/write for owner only)

---

## README.md

Application documentation automatically generated during `aifabrix create`.

**What:** Application-specific README with build instructions, prerequisites, and troubleshooting tips.

**When:** Generated automatically when running `aifabrix create` if `README.md` doesn't already exist in the application directory.

**Content:**

The README includes:
- Application display name and description
- Installation instructions
- Build commands (`aifabrix build`)
- Run commands (`aifabrix run`)
- Access URLs (with correct port)
- Container logging commands
- Push to Azure Container Registry instructions
- Prerequisites checklist (conditional based on app configuration)
- Troubleshooting tips

**Example Structure:**

```markdown
# My Application Builder

Build, run, and deploy My Application using @aifabrix/builder.

## Install
npm install -g @aifabrix/builder

## Build
aifabrix build myapp

## Run Locally
aifabrix run myapp
**Access:** http://localhost:3000

## Prerequisites
- @aifabrix/builder installed globally
- Docker Desktop running
- Infrastructure running (aifabrix up)
- PostgreSQL database (if required)
- Redis (if required)
```

**Conditional Sections:**

The README automatically includes sections based on your application configuration:
- Database prerequisites (if `requires.database: true`)
- Redis prerequisites (if `requires.redis: true`)
- Storage prerequisites (if `requires.storage: true`)
- Authentication prerequisites (if `requires.authentication: true`)

**Customization:**

If you want to customize the README, you can:
1. Edit `builder/<app>/README.md` manually after creation
2. The file will not be overwritten on subsequent `aifabrix create` runs (generation is skipped if file exists)

**Template Location:**

The README template is located at `templates/applications/README.md.hbs` and uses Handlebars templating with application context.

---

## Authentication & Access Control

Authentication and access rights are implemented using **miso-client** libraries with **1-2ms response times** thanks to Redis caching.

### Installation

**JavaScript/TypeScript:**
```bash
npm install @aifabrix/miso-client
```

**Python:**
```bash
pip install aifabrix-miso-client
```

### Basic Usage

**JavaScript/TypeScript:**
```typescript
import { MisoClient } from '@aifabrix/miso-client';

const client = new MisoClient({
  controllerUrl: process.env.MISO_CONTROLLER_URL,
  environment: process.env.MISO_ENVIRONMENT, // 'miso', 'dev', 'tst', or 'pro'
  applicationKey: process.env.APPLICATION_KEY
});

await client.initialize();

// Access control (1-2ms response from Redis cache)
if (await client.hasRole(userToken, 'admin')) {
  // Admin-only functionality
}

// Note: For detailed MisoClient configuration, see:
// https://github.com/esystemsdev/aifabrix-miso-client

// Check specific permissions
if (await client.hasRole(userToken,'documents:write')) {
  // Can write documents
}
```

**Python:**
```python
from aifabrix_miso_client import MisoClient

client = MisoClient(
    controller_url=os.getenv('MISO_CONTROLLER_URL'),
    environment=os.getenv('MISO_ENVIRONMENT'),  # 'miso', 'dev', 'tst', or 'pro'
    application_key=os.getenv('APPLICATION_KEY')
)

await client.initialize()

# Access control (1-2ms response from Redis cache)
if await client.has_role(user_token, 'admin'):
    # Admin-only functionality

# Check specific permissions
if await client.has_permission(user_token, 'documents:write'):
    # Can write documents
```

### Error Handling

**JavaScript/TypeScript:**
```typescript
try {
  const isValid = await client.validateToken(token);
  if (!isValid) {
    throw new Error('Invalid token');
  }

  const user = await client.getUser(token);
  
  // Log successful authentication
  await client.log.audit('user.login', 'authentication', {
    userId: user.id,
    ip: '192.168.1.1',
    userAgent: 'Mozilla/5.0...'
  });
  
  // ... use user data
} catch (error) {
  // Log the error
  await client.log.error('Authentication failed', {
    error: error instanceof Error ? error.message : 'Unknown error',
    token: token.substring(0, 10) + '...' // Log partial token for debugging
  });

  // Handle the error appropriately
  console.error('Authentication error:', error);
}
```

**Python:**
```python
try:
    is_valid = await client.validate_token(token)
    if not is_valid:
        raise ValueError('Invalid token')

    user = await client.get_user(token)
    
    # Log successful authentication
    await client.log.audit('user.login', 'authentication', {
        'userId': user.id,
        'ip': '192.168.1.1',
        'userAgent': 'Mozilla/5.0...'
    })
    
    # ... use user data
except Exception as e:
    # Log the error
    await client.log.error('Authentication failed', {
        'error': str(e),
        'token': token[:10] + '...'  # Log partial token for debugging
    })
    
    # Handle the error appropriately
    print(f'Authentication error: {e}')
```

### Audit Trail

All authentication and authorization decisions are automatically logged by miso-controller:

- **Login attempts** - Success/failure with timestamps
- **Permission checks** - What was requested, by whom, when
- **Role changes** - Who granted/revoked roles
- **Failed access** - Security events for monitoring

**View audit logs:**
```bash
# Via miso-controller API
curl https://controller.aifabrix.ai/api/v1/audit/logs?app=myapp
```

### Environment Variables

Add to your `env.template`:
```bash
# Miso Controller connection
MISO_CONTROLLER_URL=https://controller.aifabrix.ai
MISO_ENVIRONMENT=dev  # or 'miso', 'tst', 'pro'
APPLICATION_KEY=myapp

# Optional: Redis configuration for caching
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# Optional: Logging level
MISO_LOG_LEVEL=info

# Pipeline API Deployment (optional - for automated deployments)
MISO_CONTROLLER_URL=https://controller.aifabrix.ai
MISO_CLIENTID=ctrl-dev-myapp
MISO_CLIENTSECRET=kv://aifabrix-client-secretKeyVault
```

**Note:** Pipeline environment variables are only needed if you're using automated CI/CD deployments. Get ClientId and ClientSecret via `aifabrix app register`.

### Benefits

- **Fast responses** - 1-2ms from Redis cache
- **No ISO 27001 coding** - Compliance handled by miso-client
- **Automatic audit** - All decisions logged
- **Centralized security** - miso-controller manages everything
- **Simple integration** - Just install and use

→ [Miso Client Documentation](https://github.com/esystemsdev/aifabrix-miso-client)

---

## Common Patterns

### Multi-Database App
```yaml
requires:
  database: true
  databases:
    - name: myapp          # Primary database
    - name: myapp-analytics # Analytics database
    - name: myapp-logs     # Logs database
```

### Microservice
```yaml
app:
  type: service  # Not exposed via web UI
port: 8080
requires:
  redis: true    # For job queue
```

### Static Site / SPA
```yaml
app:
  type: webapp
port: 80
requires:
  database: false
  redis: false
build:
  language: typescript  # For build process
```

### Background Worker
```yaml
app:
  type: service
port: 3000  # Health check endpoint
requires:
  database: true
  redis: true  # Job queue
```

---

## Validation

SDK validates configuration:

```bash
aifabrix doctor
```

**Checks:**
- Required fields present
- Valid port numbers (1-65535)
- Valid app.key format (lowercase, dashes)
- Database names valid (lowercase, underscores)
- Language is typescript or python
- Registry mode is acr, external, or public

**Example errors:**
```
❌ variables.yaml: Missing required field 'app.key'
❌ variables.yaml: Port must be between 1 and 65535 (found: 99999)
❌ variables.yaml: app.key must be lowercase with dashes (found: 'MyApp')
❌ env.template: Invalid kv:// reference 'kv://missing-key' not in secrets
```

